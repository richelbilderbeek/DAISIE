{
    "collab_server" : "",
    "contents" : "DAISIE_loglik_all_choosepar2 = function(trparsopt,trparsfix,idparsopt,idparsfix,idparsmat,pars2,datalist,methode)\n{\n   trpars1 = 0 * idparsmat\n   trpars1[idparsopt] = trparsopt\n   if(length(idparsfix) != 0)\n   {\n     for(i in 1:length(idparsfix))\n     {\n       trpars1[which(idparsmat == idparsfix[i])] = trparsfix[i]\n     }\n   }\n   for(i in 1:length(idparsopt))\n   {\n     trpars1[which(idparsmat == idparsopt[i])] = trparsopt[i]\n   }\n   if(max(trpars1) > 1 || min(trpars1) < 0)\n   {\n      loglik = -Inf\n   } else\n   {\n      pars1 = trpars1/(1 - trpars1)\n      loglik = 0\n      for(i in 1:length(datalist))\n      {\n        loglik = loglik + DAISIE_loglik_all(pars1[i,],pars2,datalist[[i]],methode)\n      }\n   }\n   if(is.nan(loglik) || is.na(loglik))\n   {\n      cat(\"There are parameter values used which cause numerical problems.\\n\")\n      loglik = -Inf\n   }\n   return(loglik)\n}\n\nDAISIE_ML2 = function(datalist,idparsmat,initparsopt,idparsopt,parsfix,idparsfix, res = 100, ddmodel = 0, cond = 0, tol = c(1E-4, 1E-5, 1E-7), maxiter = 1000 * round((1.25)^length(idparsopt)), methode = 'lsodes',optimmethod = 'subplex')\n{\n# datalist = list of all data: branching times, status of clade, and numnber of missing species\n# datalist[[,]][1] = list of branching times (positive, from present to past)\n# - max(brts) = age of the island\n# - next largest brts = stem age / time of divergence from the mainland\n# The interpretation of this depends on stac (see below)\n# For stac = 0, this needs to be specified only once.\n# For stac = 1, this is the time since divergence from the immigrant's sister on the mainland.\n# The immigrant must have immigrated at some point since then.\n# For stac = 2 and stac = 3, this is the time since divergence from the mainland.\n# The immigrant that established the clade on the island must have immigrated precisely at this point.\n# For stac = 3, it must have reimmigrated, but only after the first immigrant had undergone speciation.\n# - min(brts) = most recent branching time (only for stac = 2, or stac = 3)\n# datalist[[,]][2] = list of status of the clades formed by the immigrant\n#  . stac == 0 : immigrant is not present and has not formed an extant clade\n# Instead of a list of zeros, here a number must be given with the number of clades having stac = 0\n#  . stac == 1 : immigrant is present but has not formed an extant clade\n#  . stac == 2 : immigrant is not present but has formed an extant clade\n#  . stac == 3 : immigrant is present and has formed an extant clade\n#  . stac == 4 : immigrant is present but has not formed an extant clade, and it is known when it immigrated.\n#  . stac == 5 : immigrant is not present and has not formed an extent clade, but only an endemic species\n# datalist[[,]][3] = list with number of missing species in clades for stac = 2 and stac = 3;\n# for stac = 0 and stac = 1, this number equals 0.\n# idparsmat = matrix containing the ids of the parameters, linking them to initparsopt and parsfix.\n# Per island system we use the following order\n# - lac = (initial) cladogenesis rate\n# - mu = extinction rate\n# - K = maximum number of species possible in the clade\n# - gam = (initial) immigration rate\n# - laa = (initial) anagenesis rate\n# Example: idparsmat = rbind(c(1,2,3,4,5),c(1,2,3,6,7)) has different rates of colonization and anagenesis for the two islands.    \n# initparsopt, parsfix = values of optimized and fixed model parameters\n# idparsopt, idparsfix = ids of optimized and fixed model parameters\n# - res = pars2[1] = lx = length of ODE variable x\n# - ddmodel = pars2[2] = diversity-dependent model,mode of diversity-dependence\n#  . ddmodel == 0 : no diversity-dependence\n#  . ddmodel == 1 : linear dependence in speciation rate (anagenesis and cladogenesis)\n#  . ddmodel == 11 : linear dependence in speciation rate and immigration rate\n#  . ddmodel == 3 : linear dependence in extinction rate\n# - cond = conditioning; currently only cond = 0 is possible\n#  . cond == 0 : no conditioning\n#  . cond == 1 : conditioning on presence on the island\n\noptions(warn=-1)\nnumisl = length(datalist)\nmissnumspec = 0\nfor(i in 1:numisl)\n{ \n   missnumspec = missnumspec + sum(unlist(lapply(datalist[[i]],function(list) {list$missing_species})))\n}\nif(missnumspec > (res - 1))\n{\n   stop(\"The number of missing species is too large relative to the resolution of the ODE.\\n\",call. = FALSE)\n} \nif((unique(idparsmat) != sort(c(idparsopt,idparsfix))) || (length(initparsopt) != length(idparsopt)) || (length(parsfix) != length(idparsfix)))\n{\n   stop(\"The parameters to be optimized and/or fixed are incoherent.\\n\",call. = FALSE)\n}\ncat(\"Calculating the likelihood for the initial parameters.\",\"\\n\")\nflush.console()\ntrparsopt = initparsopt/(1 + initparsopt)\ntrparsopt[which(initparsopt == Inf)] = 1\ntrparsfix = parsfix/(1 + parsfix)\ntrparsfix[which(parsfix == Inf)] = 1\npars2 = c(res,ddmodel,cond,0,NA,tol,maxiter)\noptimpars = c(tol,maxiter)\ninitloglik = DAISIE_loglik_all_choosepar2(trparsopt = trparsopt,trparsfix = trparsfix,idparsopt = idparsopt,idparsfix = idparsfix,idparsmat = idparsmat, pars2 = pars2,datalist = datalist,methode)\ncat(\"The loglikelihood for the initial parameter values is\",initloglik,\"\\n\")\nif(initloglik == -Inf)\n{\n  stop(\"The initial parameter values have a likelihood that is equal to 0 or below machine precision. Try again with different initial values.\\n\", call. = FALSE)\n}\ncat(\"Optimizing the likelihood - this may take a while.\",\"\\n\")\nflush.console()\nout = DDD::optimizer(optimmethod = optimmethod,optimpars = optimpars,fun = DAISIE_loglik_all_choosepar2,trparsopt = trparsopt,idparsopt = idparsopt,trparsfix = trparsfix,idparsfix = idparsfix,idparsmat = idparsmat,pars2 = pars2,datalist = datalist,methode = methode)\nif(out$conv != 0)\n{\n   stop(\"Optimization has not converged. Try again with different initial values.\\n\",call. = FALSE)\n}\nMLtrpars = as.numeric(unlist(out$par))\nMLpars = MLtrpars/(1 - MLtrpars)\nML = as.numeric(unlist(out$fvalues))\nMLpars1 = 0 * idparsmat\nif(length(idparsfix) != 0)\n{\n  for(i in 1:length(idparsfix))\n  {\n    MLpars1[which(idparsmat == idparsfix[i])] = parsfix[i]\n  }\n}\nfor(i in 1:length(idparsopt))\n{\n  MLpars1[which(idparsmat == idparsopt[i])] = MLpars[i]\n}\nfor(i in 1:numisl)\n{\n  if(MLpars1[i,3] > 10^7)\n  {\n    MLpars1[i,3] = Inf\n  }\n}\nout2 = data.frame(lambda_c = MLpars1[,1], mu = MLpars1[,2], K = MLpars1[,3], gamma = MLpars1[,4], lambda_a = MLpars1[,5], loglik = ML, df = length(initparsopt), conv = unlist(out$conv))\ns1 = sprintf('Maximum likelihood parameter estimates: %f', MLpars1)\ns2 = sprintf('Maximum loglikelihood: %f',ML)\ncat(\"\\n\",s1,\"\\n\",s2,\"\\n\")\nreturn(invisible(out2))\n}",
    "created" : 1481541670751.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2565325865",
    "id" : "F8D39349",
    "lastKnownWriteTime" : 1481558724,
    "last_content_update" : 1481558724740,
    "path" : "D:/data/Ms/DAISIE/DAISIE/R/DAISIE_ML2.R",
    "project_path" : "R/DAISIE_ML2.R",
    "properties" : {
    },
    "relative_order" : 17,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}